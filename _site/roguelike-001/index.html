<!DOCTYPE html>
<html lang="en">

  <link rel="shortcut icon" type="image/png" href="/favicon.png"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Roguelike 001 - Making an ASCII Roguelike in C++ | batchler.me</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Roguelike 001 - Making an ASCII Roguelike in C++" />
<meta name="author" content="Corey Batchler" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Table of Contents The Motivation Getting Started The Main Loop The Game Class Entity, Mob, and Player Class The Floor Class The Game View Player Input and Movement" />
<meta property="og:description" content="Table of Contents The Motivation Getting Started The Main Loop The Game Class Entity, Mob, and Player Class The Floor Class The Game View Player Input and Movement" />
<link rel="canonical" href="/roguelike-001/" />
<meta property="og:url" content="/roguelike-001/" />
<meta property="og:site_name" content="batchler.me" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-04-20T20:30:00+10:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Roguelike 001 - Making an ASCII Roguelike in C++" />
<script type="application/ld+json">
{"datePublished":"2021-04-20T20:30:00+10:00","description":"Table of Contents The Motivation Getting Started The Main Loop The Game Class Entity, Mob, and Player Class The Floor Class The Game View Player Input and Movement","mainEntityOfPage":{"@type":"WebPage","@id":"/roguelike-001/"},"url":"/roguelike-001/","author":{"@type":"Person","name":"Corey Batchler"},"headline":"Roguelike 001 - Making an ASCII Roguelike in C++","dateModified":"2021-04-20T20:30:00+10:00","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="batchler.me" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">batchler.me</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/posts/">Posts</a><a class="page-link" href="/projects/">Projects</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Roguelike 001 - Making an ASCII Roguelike in C++</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2021-04-20T20:30:00+10:00" itemprop="datePublished">Apr 20, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="table-of-contents">Table of Contents</h2>
<ul>
  <li><a href="#the-motivation">The Motivation</a></li>
  <li><a href="#getting-started">Getting Started</a></li>
  <li><a href="#the-main-loop">The Main Loop</a></li>
  <li><a href="#the-game-class">The Game Class</a></li>
  <li><a href="#entity-mob-and-player-class">Entity, Mob, and Player Class</a></li>
  <li><a href="#the-floor-class">The Floor Class</a></li>
  <li><a href="#the-game-view">The Game View</a></li>
  <li><a href="#player-input-and-movement">Player Input and Movement</a></li>
</ul>

<p><br /></p>

<p>Welcome to my tutorial, thoughts, and philosophy regarding easy and logical game design. This tutorial series will see the creation of my ASCII roguelike, Chasms, which is heavily inspired by <a href="http://www.zincland.com/powder/">POWDER</a>, and admittedly, is my only exposure to the roguelike genre.</p>

<p>Chasms will be written with C++, but do not be deterred. This series tries to avoid displaying and explaining each line of code, but rather delivers a higher level explanation of how a game executes its loop.</p>

<p>At the end of part 1, you can expect the game to look like this:</p>

<p><img src="/assets/posts/roguelike/001-gameplay.gif" alt="Gameplay" /></p>

<p><br /></p>

<h2 id="the-motivation">The Motivation</h2>

<p>As you can see in the above gameplay, Chasms is a command-line ASCII turn-based roguelike. By keeping it ASCII, we don’t have to spend any time on graphics, and the player gets the benefit of playing straight from the terminal.</p>

<p><br /></p>

<h2 id="getting-started">Getting Started</h2>

<p>Whether you are making the game in C++, C, Python, Java, or any other language, the first thing to consider is how we’re delivering our “graphics”. For this, of course, we will be utilising the <a href="https://en.wikipedia.org/wiki/Ncurses">ncurses</a> library. This will allow us to draw directly to the terminal at any position, in any colour, as well as instantly read keystrokes.</p>

<p>For C/C++, simply add the following line to your CMakeLists.txt</p>

<figure class="highlight"><pre><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS -lncurses<span class="p">)</span></code></pre></figure>

<p><em>Removing the <code class="language-plaintext highlighter-rouge">XX</code> if using C</em></p>

<p>Python comes with the curses library by default, and has <em>okay</em> accompanying documentation <a href="https://docs.python.org/3/howto/curses.html">here</a>.</p>

<p>I’ve also tried to find ncurses bindings for C# in the past but had no luck. I did, however, end up writing my own bindings by taking advantage of Dll Imports. e.g.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"libncurses.5.4.dylib"</span><span class="p">,</span> <span class="n">EntryPoint</span> <span class="p">=</span> <span class="s">"mvaddstr"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">extern</span> <span class="kt">int</span> <span class="nf">AddString</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">string</span> <span class="n">str</span><span class="p">);</span></code></pre></figure>

<p><em>I might make a separate post about this one day :)</em></p>

<p>Now, let’s consider the main control flow for our game, which is the most important thing to get right.</p>

<p><br /></p>

<h2 id="the-main-loop">The Main Loop</h2>

<p>All games are represented with a main loop. Our game will have the added benefit of omitting any taxing physics calculations present with many other genres of game.</p>

<p>Here is the order that the game will follow:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">update()</code> - all logic and input processing is done here</li>
  <li><code class="language-plaintext highlighter-rouge">draw()</code> - the screen is refreshed and redrawn to reflect the previous update</li>
  <li><code class="language-plaintext highlighter-rouge">get_input()</code> - the input is polled here, and stored to be processed in the next <code class="language-plaintext highlighter-rouge">update()</code> call.</li>
</ol>

<p>The main game itself will be presented in a class. Although the class should only be instantiated once, it still acts as a neat collection of <strong>state</strong>. It also allows us to reinstantiate it in the case we want to start a new game, for example.</p>

<p>All drawing operations will be presented in a collection of functions outside any class. Good user-friendly software will separate the view (drawing) from the controller (game); see <a href="https://en.wikipedia.org/wiki/Model–view–controller">MVC</a>.</p>

<p>Good C++ design is also to not use classes if you don’t need to, and as such, all drawing functions will be grouped in a namespace, as there is no need for keeping state.</p>

<p><br /></p>

<h2 id="the-game-class">The Game Class</h2>

<p>We want to keep track of the player here as well as all the floors and as all of the logic functions.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Game</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">next_input</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">current_floor</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Floor</span><span class="p">,</span> <span class="mi">25</span><span class="o">&gt;</span> <span class="n">floors</span><span class="p">;</span>

    <span class="n">Player</span> <span class="n">player</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">main_loop</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">update</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">get_input</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">end</span><span class="p">();</span>

<span class="nl">public:</span>
    <span class="n">Game</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">start</span><span class="p">();</span>
<span class="p">};</span></code></pre></figure>

<p><em>The Player and Floor class will be explained in a future section</em></p>

<p>The idea of this class is simple. In <code class="language-plaintext highlighter-rouge">main()</code>, a <code class="language-plaintext highlighter-rouge">Game</code> object will be instantiated and then started using <code class="language-plaintext highlighter-rouge">start()</code>. This method will initialise any other variables, then call the <code class="language-plaintext highlighter-rouge">main_loop()</code> method. The body of this function is the main game loop mentioned earlier, and <code class="language-plaintext highlighter-rouge">update()</code> and <code class="language-plaintext highlighter-rouge">get_input()</code> are shown here.</p>

<p>Before we can get into any of the drawing, we will create the <code class="language-plaintext highlighter-rouge">Player</code> class and the <code class="language-plaintext highlighter-rouge">Floor</code> class. We will create them as basic as possible for now, and extend them in future tutorials.</p>

<p><br /></p>

<h2 id="entity-mob-and-player-class">Entity, Mob, and Player Class</h2>
<p>For a larger scale game, the Entity-Component-System design is more effective than the gameobject inheritence design, but for Chasms, we mostly know what we want as a final product, and as such, can work with the somewhat easier inheritence pattern.</p>

<p>To begin, we will need a base gameobject class. I’ve come to calling this class the <strong>Entity</strong> class. Entity is defined to be:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Entity</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="p">;</span>
    <span class="n">Floor</span> <span class="n">current_floor</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure>

<p>Next, we will need an inherited class called the <code class="language-plaintext highlighter-rouge">Mob</code> (mobile object). This will act as the base for all monsters, creatures, humanoids, and indeed, the player character. For now, we will create an empty Mob class that simply inherits Entity.</p>

<p>Finally, the Player class can also simply inherit the <code class="language-plaintext highlighter-rouge">Mob</code> class with no extra members for now.</p>

<p><br /></p>

<h2 id="the-floor-class">The Floor Class</h2>
<p>Chasms takes place within a 25-floor dungeon. As such, the dungeon can entirely be described as an ordered array of 25 instances of a <code class="language-plaintext highlighter-rouge">Floor</code> class.</p>

<p>Indeed, in the Game class above, we have an <code class="language-plaintext highlighter-rouge">std::array&lt;Floor, 25&gt;</code> which describes this.</p>

<p>For a floor class, we can get away with just having a width, height, and a completely randomly generated terrain matrix which can be extended in future tutorials. A terrain matrix would be a 2D array of ints which would describe if a position is empty or solid. Since we do not necessarily know the width and height of a floor (random), we will make the terrain matrix a 2D vector created as such:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Floor</span> <span class="n">Floor</span><span class="o">::</span><span class="n">generate_floor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">Floor</span><span class="p">();</span>
    <span class="n">f</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">f</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">row</span><span class="p">).</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><em>For now, we have hardcoded height and width to be 100, but this method allows extendability.</em></p>

<p>We can then call <code class="language-plaintext highlighter-rouge">generate_floor()</code> in a loop to populate <code class="language-plaintext highlighter-rouge">Game.floors</code>. It is now time to draw all our work to the screen.</p>

<p><br /></p>

<h2 id="the-game-view">The Game View</h2>
<p>In <code class="language-plaintext highlighter-rouge">Game.start()</code>, we call <code class="language-plaintext highlighter-rouge">view::start()</code>, which initialises ncurses to modify the terminal to be ready to draw and catch keystrokes. This is done as such:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// init ncurses</span>
    <span class="n">initscr</span><span class="p">();</span>
    <span class="n">keypad</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>   <span class="c1">// allows us to capture arrow keys</span>
    <span class="n">noecho</span><span class="p">();</span>               <span class="c1">// stops echoing our keypresses</span>
    <span class="n">curs_set</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>            <span class="c1">// hides the cursor</span>

    <span class="c1">// init colors</span>
    <span class="n">start_color</span><span class="p">();</span>
    <span class="n">init_color</span><span class="p">(</span><span class="n">COLOR_GRAY</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">500</span><span class="p">);</span>  <span class="c1">// creates a gray color</span>
    <span class="n">init_pair</span><span class="p">(</span><span class="n">COLOR_GRAY</span><span class="p">,</span> <span class="n">COLOR_GRAY</span><span class="p">,</span> <span class="n">COLOR_BLACK</span><span class="p">);</span> <span class="c1">// initialises the gray color to draw</span>
<span class="p">}</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">COLOR_GRAY</code> is a constant I defined to the integer 8. This is because ncurses predefines 8 colors for us as integers [ 0, 7 ]. Also <code class="language-plaintext highlighter-rouge">view</code> is the name we have given the namespace containing all drawing methods and constants.</p>

<p>In the <code class="language-plaintext highlighter-rouge">view::draw(Game &amp;g)</code> method, we simply refresh the screen (by starting the method with <code class="language-plaintext highlighter-rouge">erase()</code> and ending with <code class="language-plaintext highlighter-rouge">refresh()</code>), and draw all the game windows (map window, secondary window, status window).</p>

<p>Each window has its own draw function associated with it. For now, we’re only interested in the map window.</p>

<p>Here is the method to draw our game view.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">draw_map</span><span class="p">(</span><span class="k">const</span> <span class="n">game</span><span class="o">::</span><span class="n">Game</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">view_radius</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">center_row</span> <span class="o">=</span> <span class="n">MAP_Y</span> <span class="o">+</span> <span class="p">(</span><span class="n">MAP_ROWS</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">center_col</span> <span class="o">=</span> <span class="n">MAP_X</span> <span class="o">+</span> <span class="p">(</span><span class="n">MAP_COLS</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">floor</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">get_floors</span><span class="p">().</span><span class="n">at</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">get_current_floor</span><span class="p">());</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="o">-</span><span class="n">view_radius</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;=</span> <span class="n">view_radius</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="o">-</span><span class="n">view_radius</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;=</span> <span class="n">view_radius</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

            <span class="kt">int</span> <span class="n">py</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">get_player</span><span class="p">().</span><span class="n">get_y</span><span class="p">()</span> <span class="o">+</span> <span class="n">row</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">px</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">get_player</span><span class="p">().</span><span class="n">get_x</span><span class="p">()</span> <span class="o">+</span> <span class="n">col</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">floor</span><span class="p">.</span><span class="n">coordinate_exists</span><span class="p">(</span><span class="n">py</span><span class="p">,</span> <span class="n">px</span><span class="p">))</span> <span class="p">{</span>
                <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="n">floor</span><span class="p">.</span><span class="n">get_terrain</span><span class="p">().</span><span class="n">at</span><span class="p">(</span><span class="n">py</span><span class="p">).</span><span class="n">at</span><span class="p">(</span><span class="n">px</span><span class="p">);</span>

                <span class="kt">int</span> <span class="n">rely</span> <span class="o">=</span> <span class="n">center_row</span> <span class="o">+</span> <span class="n">row</span><span class="p">;</span>
                <span class="kt">int</span> <span class="n">relx</span> <span class="o">=</span> <span class="n">center_col</span> <span class="o">+</span> <span class="n">col</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>

                <span class="n">attron</span><span class="p">(</span><span class="n">COLOR_PAIR</span><span class="p">(</span><span class="n">COLOR_GRAY</span><span class="p">));</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="n">EMPTY</span><span class="p">:</span>
                        <span class="n">mvaddstr</span><span class="p">(</span><span class="n">rely</span><span class="p">,</span> <span class="n">relx</span><span class="p">,</span> <span class="s">"."</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="n">WALL</span><span class="p">:</span>
                        <span class="n">mvaddstr</span><span class="p">(</span><span class="n">rely</span><span class="p">,</span> <span class="n">relx</span><span class="p">,</span> <span class="s">"#"</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">attroff</span><span class="p">(</span><span class="n">COLOR_PAIR</span><span class="p">(</span><span class="n">COLOR_GRAY</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// draw player last (to appear on top)</span>
    <span class="n">mvaddstr</span><span class="p">(</span><span class="n">center_row</span><span class="p">,</span> <span class="n">center_col</span><span class="p">,</span> <span class="s">"@"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>This is a relatively large code block, but its function is to draw terrain around with respects to the player’s position in the world space, keeping the player always in the centre of the window. Notice the view-radius is variable, and this variable very well may become a field of the Mob class in the future (once vision is implemented).</p>

<p>We describe the function <code class="language-plaintext highlighter-rouge">Floor.coordinate_exists(int y, int x)</code> as if y is in range [0, height] and x is in range [0, width].</p>

<p>We also describe the constants <code class="language-plaintext highlighter-rouge">EMPTY</code> to be the integer 0, and <code class="language-plaintext highlighter-rouge">WALL</code> to be the integer 1. This is what populates our <code class="language-plaintext highlighter-rouge">Floor.terrain</code>. Empty space is drawn using the ‘.’ character, while walls are drawn with ‘#’.</p>

<p>The only thing we need to do now is add movement and we’ll have completed tutorial 001.</p>

<p><br /></p>

<h2 id="player-input-and-movement">Player Input and Movement</h2>
<p>Returning to the Game class, we recall our <code class="language-plaintext highlighter-rouge">get_input()</code> method which is called last in the main loop. This method is entirely defined as:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">get_input</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">next_input</span> <span class="o">=</span> <span class="n">getch</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure>

<p>Easy, right?</p>

<p>This stores our keystroke in a field to be processed at the next <code class="language-plaintext highlighter-rouge">update()</code> call. Speaking of which, our <code class="language-plaintext highlighter-rouge">update()</code> method is only comprised of a call to the <code class="language-plaintext highlighter-rouge">process_input()</code> method, which we’ve defined as follows:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="n">Game</span><span class="o">::</span><span class="n">process_input</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">next_input</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="sc">'q'</span><span class="p">:</span>
            <span class="n">end</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">KEY_LEFT</span><span class="p">:</span>
            <span class="n">player</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">KEY_RIGHT</span><span class="p">:</span>
            <span class="n">player</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">KEY_UP</span><span class="p">:</span>
            <span class="n">player</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">KEY_DOWN</span><span class="p">:</span>
            <span class="n">player</span><span class="p">.</span><span class="n">translate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><em>Where</em> <code class="language-plaintext highlighter-rouge">translate</code> <em>is a Mob method that translates our x and y values</em>.</p>

<p>That was the final step. Congratulations! Now, you should have a game in the same state as what is presented in the first gif.</p>

<p>Continue to <a href="/roguelike-002/">002 - Floor Generation</a></p>

  </div><a class="u-url" href="/roguelike-001/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">batchler.me</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Corey Batchler</li><li><a class="u-email" href="mailto:corey@batchler.me">corey@batchler.me</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/trithagoras"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">trithagoras</span></a></li><li><a href="https://www.linkedin.com/in/coreybatchler"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">coreybatchler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Third year CS student at the University of Queensland.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
