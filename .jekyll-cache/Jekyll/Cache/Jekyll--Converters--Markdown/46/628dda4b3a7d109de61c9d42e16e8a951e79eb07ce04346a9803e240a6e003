I"-&<p>Welcome to my tutorial, thoughts, and philosophy regarding easy and logical game design. This tutorial series will see the creation of my ASCII roguelike, Chasms, which is heavily inspired by <a href="http://www.zincland.com/powder/">POWDER</a>, and admittedly, is my only exposure to the roguelike genre.</p>

<p>Chasms will be written with C++, but do not be deterred. This series tries to avoid displaying and explaining each line of code, but rather delivers a higher level explanation of how a game executes its loop.</p>

<p>At the end of part 1, you can expect the game to look like this:</p>

<p><img src="/assets/001-gameplay.gif" alt="Gameplay" /></p>

<p><br /></p>

<h2 id="the-motivation">The Motivation</h2>

<p>As you can see in the above gameplay, Chasms is a command-line ASCII turn-based roguelike. By keeping it ASCII, we don’t have to spend any time on graphics, and the player gets the benefit of playing straight from the terminal.</p>

<p><br /></p>

<h2 id="getting-started">Getting Started</h2>

<p>Whether you are making the game in C++, C, Python, Java, or any other language, the first thing to consider is how we’re delivering our “graphics”. For this, of course, we will be utilising the <a href="https://en.wikipedia.org/wiki/Ncurses">ncurses</a> library. This will allow us to draw directly to the terminal at any position, in any colour, as well as instantly read keystrokes.</p>

<p>For C/C++, simply add the following line to your CMakeLists.txt</p>

<figure class="highlight"><pre><code class="language-cmake" data-lang="cmake"><span class="nb">set</span><span class="p">(</span>CMAKE_CXX_FLAGS -lncurses<span class="p">)</span></code></pre></figure>

<p><em>Removing the <code class="language-plaintext highlighter-rouge">XX</code> if using C</em></p>

<p>Python comes with the curses library by default, and has <em>okay</em> accompanying documentation <a href="https://docs.python.org/3/howto/curses.html">here</a>.</p>

<p>I’ve also tried to find ncurses bindings for C# in the past but had no luck. I did, however, end up writing my own bindings by taking advantage of Dll Imports. e.g.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="p">[</span><span class="nf">DllImport</span><span class="p">(</span><span class="s">"libncurses.5.4.dylib"</span><span class="p">,</span> <span class="n">EntryPoint</span> <span class="p">=</span> <span class="s">"mvaddstr"</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">extern</span> <span class="kt">int</span> <span class="nf">AddString</span><span class="p">(</span><span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">string</span> <span class="n">str</span><span class="p">);</span></code></pre></figure>

<p><em>I might make a separate post about this one day :)</em></p>

<p>Now, let’s consider the main control flow for our game, which is the most important thing to get right.</p>

<p><br /></p>

<h2 id="the-main-loop">The Main Loop</h2>

<p>All games are represented with a main loop. Our game will have the added benefit of omitting any taxing physics calculations present with many other genres of game.</p>

<p>Here is the order that the game will follow:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">update()</code> - all logic and input processing is done here</li>
  <li><code class="language-plaintext highlighter-rouge">draw()</code> - the screen is refreshed and redrawn to reflect the previous update</li>
  <li><code class="language-plaintext highlighter-rouge">get_input()</code> - the input is polled here, and stored to be processed in the next <code class="language-plaintext highlighter-rouge">update()</code> call.</li>
</ol>

<p>The main game itself will be presented in a class. Although the class should only be instantiated once, it still acts as a neat collection of <strong>state</strong>. It also allows us to reinstantiate it in the case we want to start a new game, for example.</p>

<p>All drawing operations will be presented in a collection of functions outside any class. Good user-friendly software will separate the view (drawing) from the controller (game); see <a href="https://en.wikipedia.org/wiki/Model–view–controller">MVC</a>.</p>

<p>Good C++ design is also to not use classes if you don’t need to, and as such, all drawing functions will be grouped in a namespace, as there is no need for keeping state.</p>

<p><br /></p>

<h2 id="the-game-state">The Game State</h2>
<p>The state of a program is recursively defined as a set of the state of all of its variables.</p>

<p>We consider the <strong>basic</strong> data type (int, bool, char, float, etc.) and the <strong>composite</strong> data type (arrays, structs, classes, etc.). We recognise that any composite data type can be recursively constructed with basic data types.</p>

<p>With this knowledge, plus the knowledge that the state of any basic data type variable is simply its value, we can conclude that the state of any composite data type is recursively defined as the state of all of its fields.</p>

<p>As an example, consider the following class:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Entity</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="p">;</span>
    <span class="n">Floor</span> <span class="n">current_floor</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
<span class="p">};</span></code></pre></figure>

<p>And an entity s defined as such (noting &lt;?&gt; here represents an object we don’t necessarily need to know the value of):</p>

<p><code class="language-plaintext highlighter-rouge">s.name = "Gold Coin"; s.description = "shiny"; s.current_floor = &lt;?&gt;; s.y = 4; s.x = 10</code></p>

<p>Then we can say the state of Entity s is the following tuple:</p>

<p>( “Gold Coin”, “shiny”, <code class="language-plaintext highlighter-rouge">State(s.current_floor)</code>, 4, 10)</p>

<p>This is important, as now we can construct classes by considering the state we wish to keep. In our Game class, we want at least 25 <em>floors</em>, each with a set of <em>entities</em> that exist on that floor, and a reference to our <em>player</em> object. We can now consider our Game class.</p>

<p><br /></p>

<h2 id="the-game-class">The Game Class</h2>

<p>So now we know we want to keep track of the player here as well as all the floors. We also want the class to consist of the logic functions, but these do not compose state, they simply act to modify existing state.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">Game</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">next_input</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">current_floor</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Floor</span><span class="p">,</span> <span class="mi">25</span><span class="o">&gt;</span> <span class="n">floors</span><span class="p">;</span>

    <span class="n">Player</span> <span class="n">player</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">main_loop</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">update</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">get_input</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">end</span><span class="p">();</span>

<span class="nl">public:</span>
    <span class="n">Game</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">start</span><span class="p">();</span>
<span class="p">};</span></code></pre></figure>

<p><em>The Player and Floor class will be explained in a future section</em></p>

<p>The idea of this class is simple. In <code class="language-plaintext highlighter-rouge">main()</code>, a <code class="language-plaintext highlighter-rouge">Game</code> object will be instantiated and then started using <code class="language-plaintext highlighter-rouge">start()</code>. This method will initialise any other variables, then call the <code class="language-plaintext highlighter-rouge">main_loop()</code> method. The body of this function is the main game loop mentioned earlier, and <code class="language-plaintext highlighter-rouge">update()</code> and <code class="language-plaintext highlighter-rouge">get_input()</code> are shown here.</p>

<p>What’s most important to us right now is some feedback. We will now investigate drawing of the game.</p>

<p><br /></p>

<h2 id="the-game-view">The Game View</h2>
<p>In <code class="language-plaintext highlighter-rouge">Game::start()</code>, we initialise ncurses to modify the terminal to be ready to draw and catch keystrokes. This is done as such:</p>

<p>void start() {
    // init ncurses
    initscr();
    keypad(stdscr, true);
    noecho();
    curs_set(0);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// init colors
start_color();
init_color(COLOR_GRAY, 500, 500, 500);
init_pair(COLOR_GRAY, COLOR_GRAY, COLOR_BLACK); }
</code></pre></div></div>
:ET