I"®-<p>Previous part: <a href="/roguelike-001/">001 - Making an ASCII Roguelike in C++</a></p>

<p><br /></p>

<h2 id="table-of-contents">Table of Contents</h2>
<ol>
  <li><a href="#generating-the-maze">Generating the Maze</a></li>
  <li><a href="#adding-rooms">Adding Rooms</a></li>
  <li><a href="#adding-doorways">Adding Doorways</a></li>
</ol>

<p><br /></p>

<p>Welcome to part 002. In this part, we‚Äôll discuss how we will randomly generate all the floors in our game. We will accomplish this by running a maze-generator algorithm, and then randomly placing pre-made rooms onto the map.</p>

<p>At the end of the tutorial, our floors should look like this:</p>

<p>CONTENT HERE</p>

<p><br /></p>

<h2 id="generating-the-maze">Generating the Maze</h2>

<p><a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_depth-first_search">Randomized depth-first search</a> is the algorithm we will use to generate our maze. You can read the algorithm steps in the link. I chose to implement it iteratively, as much as I would have liked to implement it recursively, I couldn‚Äôt wrap my head around a tail-recursive solution, and an otherwise recursive solution would likely overflow the stack. We will get into the implementation steps soon.</p>

<p>The first thing I did was set up randomness in the project. For this, we need to generate a random seed using <code class="language-plaintext highlighter-rouge">srand(time(0))</code>. I stored this value in a new field <code class="language-plaintext highlighter-rouge">Game::world_seed</code>, and later in the project, I‚Äôd like to implement a way for the player to input a seed and play a dungeon they can predict.</p>

<p>I then began to extend on the <code class="language-plaintext highlighter-rouge">Floor::generate_floor()</code> static method, where I modified the width and height of the generated floor to:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">f</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">f</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span></code></pre></figure>

<p>So that height, width is an odd number in the range \([31, 49]\). These limits are arbitrary, so long as they‚Äôre odd numbers \(&gt; 1\). This is a requirement for the next step in our maze generation.</p>

<p>Previously, we were completely randomizing our floor terrain in a nested <code class="language-plaintext highlighter-rouge">for</code> loop. Now, we want to format our grid to look like this:</p>

<p><img src="/assets/posts/roguelike/002-empty-grid.png" alt="Grid pattern" /></p>

<p>To do this, we change our loop to this:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">col</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">row</span><span class="p">).</span><span class="n">push_back</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">row</span><span class="p">).</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Where you may expect the value of our <em>cell</em> (empty space surrounded by walls) to be 0, it is instead -1. Remembering back to our decision to make this an integer so that we can extend our terrain with potentially many different <em>variants</em> of terrain, we can also use the value -1 as an ‚Äúunvisited flag‚Äù, meaning when we run our algorithm, it‚Äôll check if a cell has been visited (0) or unvisited (-1).</p>

<p>With our now empty grid of cells all marked as unvisited, it is time to run through our algorithm.</p>

<p>As described in the article, we need a stack where we can push / pop cells. For this, I used a deque of tuples of y, x values.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">();</span></code></pre></figure>

<p>We then need to choose an initial cell,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">ry</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">rx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>mark it as empty, and push it to the stack.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">ry</span><span class="p">).</span><span class="n">at</span><span class="p">(</span><span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">d</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ry</span><span class="p">,</span> <span class="n">rx</span><span class="p">));</span></code></pre></figure>

<p>We then run the while loop described in the article, knocking down walls between cells, or ignoring if the chosen cell has been visited, until our stack is empty. At this point, our maze is done and should look like this:</p>

<p><img src="/assets/posts/roguelike/002-maze.gif" alt="our generated maze" /></p>

<p><em>as always, full code can be found at my <a href="https://github.com/trithagoras/chasms-cpp">github repository</a></em></p>

<p>At this point, we can guarantee that any two empty spaces on the map are linked by at least one path. It is now time to add rooms.</p>

<p><br /></p>

<h2 id="adding-rooms">Adding Rooms</h2>

<p><br /></p>

<h2 id="adding-doorways">Adding Doorways</h2>
<p>Before adding rooms, we could guarantee that there exists a path between any two spaces on the map. Now, we cannot guarantee that. For example, below shows us a room that even if there was a doorway where the player is, the corridor it connects to is disconnected from the rest of the map.</p>

<p><img src="/assets/posts/roguelike/002-no-doors.png" alt="paths are no longer connected" /></p>

<p>For this, we need to carefully consider how to add doorways such that the map is still fully connected.</p>

<p>For this, I‚Äôve come up with my own <strong>door-adding algorithm</strong>. Which goes like this:</p>

<ol>
  <li>Start at some random wall of the room where a door can go and place a door.</li>
  <li>Move clockwise around the room until another possible doorway is found.
    <ol>
      <li>If there exists a path between the old doorway and the new doorway, then repeat from step 2.</li>
      <li>Else; check if it can path to any of the other doors
        <ol>
          <li>If it can, repeat from step 2.</li>
          <li>Else; create a door here and repeat from step 2.</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p>Each time you <em>repeat from step 2.</em>, it should be done so that the <em>old doorway</em> is set to be the possible doorway given by the last step rather than the chosen doorway from step 1. This is done for efficiency reasons and is not a requirement for the algorithm.</p>

<p>This algorithm should ensure the fewest number of doors while staying connected. Now all we need is an algorithm that can find a path between any two points. Luckily, we have everything set up for us to treat the matrix as a mathematical <em>graph</em>, and we can use <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first search</a> to find a path between any two nodes.</p>

<p>We already used randomized depth-first search earlier to generate our maze, and implementing this should be easy.</p>
:ET