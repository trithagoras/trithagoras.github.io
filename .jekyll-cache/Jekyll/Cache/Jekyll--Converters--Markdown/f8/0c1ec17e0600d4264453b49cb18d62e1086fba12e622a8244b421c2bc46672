I"|C<p>Previous part: <a href="/roguelike-001/">001 - Making an ASCII Roguelike in C++</a></p>

<p><br /></p>

<h2 id="table-of-contents">Table of Contents</h2>
<ol>
  <li><a href="#generating-the-maze">Generating the Maze</a></li>
  <li><a href="#adding-rooms">Adding Rooms</a></li>
  <li><a href="#adding-doorways">Adding Doorways</a></li>
</ol>

<p><br /></p>

<p>Welcome to part 002. In this part, we’ll discuss how we will randomly generate all the floors in our game. We will accomplish this by running a maze-generator algorithm, and then randomly placing pre-made rooms onto the map.</p>

<p>At the end of the tutorial, our floors should look like this:</p>

<p>CONTENT HERE</p>

<p><br /></p>

<h2 id="generating-the-maze">Generating the Maze</h2>

<p><a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_depth-first_search">Randomized depth-first search</a> is the algorithm we will use to generate our maze. You can read the algorithm steps in the link. I chose to implement it iteratively, as much as I would have liked to implement it recursively, I couldn’t wrap my head around a tail-recursive solution, and an otherwise recursive solution would likely overflow the stack. We will get into the implementation steps soon.</p>

<p>The first thing I did was set up randomness in the project. For this, we need to generate a random seed using <code class="language-plaintext highlighter-rouge">srand(time(0))</code>. I stored this value in a new field <code class="language-plaintext highlighter-rouge">Game::world_seed</code>, and later in the project, I’d like to implement a way for the player to input a seed and play a dungeon they can predict.</p>

<p>I then began to extend on the <code class="language-plaintext highlighter-rouge">Floor::generate_floor()</code> static method, where I modified the width and height of the generated floor to:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">f</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">f</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span></code></pre></figure>

<p>So that height, width is an odd number in the range \([31, 49]\). These limits are arbitrary, so long as they’re odd numbers \(&gt; 1\). This is a requirement for the next step in our maze generation.</p>

<p>Previously, we were completely randomizing our floor terrain in a nested <code class="language-plaintext highlighter-rouge">for</code> loop. Now, we want to format our grid to look like this:</p>

<p><img src="/assets/posts/roguelike/002-empty-grid.png" alt="Grid pattern" /></p>

<p>To do this, we change our loop to this:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">col</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">row</span><span class="p">).</span><span class="n">push_back</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">row</span><span class="p">).</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Where you may expect the value of our <em>cell</em> (empty space surrounded by walls) to be 0, it is instead -1. Remembering back to our decision to make this an integer so that we can extend our terrain with potentially many different <em>variants</em> of terrain, we can also use the value -1 as an “unvisited flag”, meaning when we run our algorithm, it’ll check if a cell has been visited (0) or unvisited (-1).</p>

<p>With our now empty grid of cells all marked as unvisited, it is time to run through our algorithm.</p>

<p>As described in the article, we need a stack where we can push / pop cells. For this, I used a deque of tuples of y, x values.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">();</span></code></pre></figure>

<p>We then need to choose an initial cell,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">ry</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">rx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>mark it as empty, and push it to the stack.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">ry</span><span class="p">).</span><span class="n">at</span><span class="p">(</span><span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">d</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ry</span><span class="p">,</span> <span class="n">rx</span><span class="p">));</span></code></pre></figure>

<p>We then run the while loop described in the article, knocking down walls between cells, or ignoring if the chosen cell has been visited, until our stack is empty. At this point, our maze is done and should look like this:</p>

<p><img src="/assets/posts/roguelike/002-maze.gif" alt="our generated maze" /></p>

<p><em>as always, full code can be found at my <a href="https://github.com/trithagoras/chasms-cpp">github repository</a></em></p>

<p>At this point, we can guarantee that any two empty spaces on the map are linked by at least one path. It is now time to add rooms.</p>

<p><br /></p>

<h2 id="adding-rooms">Adding Rooms</h2>
<p>The way I’ve decided I’ll implement rooms is by having a <code class="language-plaintext highlighter-rouge">maps.json</code> file that will contain predefined rooms by size which will simply encode terrain data. Later in the project, maps will ideally encode data such as secret rooms, items, and mob spawns.</p>

<p>This <code class="language-plaintext highlighter-rouge">maps.json</code> file will not be included in the compilation, but rather, should be included alongside the compilation and read from at runtime, so that modders can easily add new rooms.</p>

<p>I will also allow <em>basic</em> rooms of random size to be computed, where a basic room is an empty room surrounded by walls.</p>

<p>Then, after the maze has been generated, random rooms will be both chosen from our file or computed with our instructions, and scattered across the map, overwriting the terrain that’s already there.</p>

<p>In order to read <code class="language-plaintext highlighter-rouge">maps.json</code>, we’ll need to use a third-party library that can do this. For this project, we’ll be using <a href="https://github.com/nlohmann/json">Nlohmann JSON</a>, which is a very popular JSON library.</p>

<p>To include this library (MacOS instructions), I used the package manager <a href="https://brew.sh">Homebrew</a> and ran the commands:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>brew tap nlohmann/json
<span class="nv">$ </span>brew <span class="nb">install </span>nlohmann-json</code></pre></figure>

<p>and added the following lines to my <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code></p>

<figure class="highlight"><pre><code class="language-cmake" data-lang="cmake"><span class="nb">find_package</span><span class="p">(</span>nlohmann_json 3.2.0 REQUIRED<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>chasms PRIVATE nlohmann_json::nlohmann_json<span class="p">)</span></code></pre></figure>

<p>and finally, as a convenience, where I’ll be using the library, I’ve written:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">using</span> <span class="n">json</span> <span class="o">=</span> <span class="n">nlohmann</span><span class="o">::</span><span class="n">json</span><span class="p">;</span></code></pre></figure>

<p><em>of course, there are many ways to include the library, and all of which are present at the github repository linked above.</em></p>

<p>Now that we have the JSON reader, we should create our <code class="language-plaintext highlighter-rouge">maps.json</code>.</p>

<figure class="highlight"><pre><code class="language-json" data-lang="json"><span class="p">{</span><span class="w">
    </span><span class="nl">"maps"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"height"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
            </span><span class="nl">"width"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
            </span><span class="nl">"map"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"# # # # #"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"# . . . #"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"# . # . #"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"# . . . #"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"# # # # #"</span><span class="w">
            </span><span class="p">]</span><span class="w">
        </span><span class="p">},</span><span class="w">

        </span><span class="p">{</span><span class="w">
            </span><span class="nl">"height"</span><span class="p">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w">
            </span><span class="nl">"width"</span><span class="p">:</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w">
            </span><span class="nl">"map"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
                </span><span class="s2">"# # # # # #"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"# . . . . #"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"# . # # . #"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"# . # # . #"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"# . . . . #"</span><span class="p">,</span><span class="w">
                </span><span class="s2">"# # # # # #"</span><span class="w">
            </span><span class="p">]</span><span class="w">
        </span><span class="p">}</span><span class="w">
    </span><span class="p">]</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>This is the contents of our file for now which can be extended at any time. Just place this in a subdirectory <code class="language-plaintext highlighter-rouge">/assets/</code> within the output directory.</p>

<p><br /></p>

<h2 id="adding-doorways">Adding Doorways</h2>
<p>Before adding rooms, we could guarantee that there exists a path between any two spaces on the map. Now, we cannot guarantee that. For example, below shows us a room that even if there was a doorway where the player is, the corridor it connects to is disconnected from the rest of the map.</p>

<p><img src="/assets/posts/roguelike/002-no-doors.png" alt="paths are no longer connected" /></p>

<p>For this, we need to carefully consider how to add doorways such that the map is still fully connected.</p>

<p>For this, I’ve come up with my own <strong>door-adding algorithm</strong>. Which goes like this:</p>

<ol>
  <li>Start at some random wall of the room where a door can go and place a door.</li>
  <li>Move clockwise around the room until another possible doorway is found.
    <ol>
      <li>If there exists a path between the old doorway and the new doorway, then repeat from step 2.</li>
      <li>Else; check if it can path to any of the other doors
        <ol>
          <li>If it can, repeat from step 2.</li>
          <li>Else; create a door here and repeat from step 2.</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p>Each time you <em>repeat from step 2.</em>, it should be done so that the <em>old doorway</em> is set to be the possible doorway given by the last step rather than the chosen doorway from step 1. This is done for efficiency reasons and is not a requirement for the algorithm.</p>

<p>This algorithm should ensure the fewest number of doors while staying connected. Now all we need is an algorithm that can find a path between any two points. Luckily, we have everything set up for us to treat the matrix as a mathematical <em>graph</em>, and we can use <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first search</a> to find a path between any two nodes.</p>

<p>We already used randomized depth-first search earlier to generate our maze, and implementing this should be easy.</p>
:ET