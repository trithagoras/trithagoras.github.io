I"ÿ#<p>Previous part: <a href="/roguelike-001/">001 - Making an ASCII Roguelike in C++</a></p>

<p><br /></p>

<h2 id="table-of-contents">Table of Contents</h2>
<p>pass</p>

<p><br /></p>

<p>Welcome to part 002. In this part, we‚Äôll discuss how we will randomly generate all the floors in our game. We will accomplish this by running a maze-generator algorithm, and then randomly placing pre-made rooms onto the map.</p>

<p>At the end of the tutorial, our floors should look like this:</p>

<p>CONTENT HERE</p>

<p><br /></p>

<h2 id="generating-the-maze">Generating the Maze</h2>

<p><a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_depth-first_search">Randomized depth-first search</a> is the algorithm we will use to generate our maze. You can read the algorithm steps in the link. I chose to implement it iteratively, as much as I would have liked to implement it recursively, I couldn‚Äôt wrap my head around a tail-recursive solution, and an otherwise recursive solution would likely overflow the stack. We will get into the implementation steps soon.</p>

<p>The first thing I did was set up randomness in the project. For this, we need to generate a random seed using <code class="language-plaintext highlighter-rouge">srand(time(0))</code>. I stored this value in a new field <code class="language-plaintext highlighter-rouge">Game::world_seed</code>, and later in the project, I‚Äôd like to implement a way for the player to input a seed and play a dungeon they can predict.</p>

<p>I then began to extend on the <code class="language-plaintext highlighter-rouge">Floor::generate_floor()</code> static method, where I modified the width and height of the generated floor to:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">f</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span>
<span class="n">f</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="mi">31</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span></code></pre></figure>

<p>So that height, width is an odd number in the range \([31, 49]\). These limits are arbitrary, so long as they‚Äôre odd numbers \(&gt; 1\). This is a requirement for the next step in our maze generation.</p>

<p>Previously, we were completely randomizing our floor terrain in a nested <code class="language-plaintext highlighter-rouge">for</code> loop. Now, we want to format our grid to look like this:</p>

<p><img src="/assets/posts/roguelike/002-empty-grid.png" alt="Grid pattern" /></p>

<p>To do this, we change our loop to this:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">height</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">width</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">col</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">row</span><span class="p">).</span><span class="n">push_back</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">row</span><span class="p">).</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Where you may expect the value of our <em>cell</em> (empty space surrounded by walls) to be 0, it is instead -1. Remembering back to our decision to make this an integer so that we can extend our terrain with potentially many different <em>variants</em> of terrain, we can also use the value -1 as an ‚Äúunvisited flag‚Äù, meaning when we run our algorithm, it‚Äôll check if a cell has been visited (0) or unvisited (-1).</p>

<p>With our now empty grid of cells all marked as unvisited, it is time to run through our algorithm.</p>

<p>As described in the article, we need a stack where we can push / pop cells. For this, I used a deque of tuples of y, x values.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">();</span></code></pre></figure>

<p>We then need to choose an initial cell,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">ry</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">rx</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>mark it as empty, and push it to the stack.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">f</span><span class="p">.</span><span class="n">terrain</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">ry</span><span class="p">).</span><span class="n">at</span><span class="p">(</span><span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">d</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ry</span><span class="p">,</span> <span class="n">rx</span><span class="p">));</span></code></pre></figure>

<p>We then run the while loop described in the article, knocking down walls between cells, or ignoring if the chosen cell has been visited, until our stack is empty. At this point, our maze is done and should look like this:</p>

<p><img src="/assets/posts/roguelike/002-maze.gif" alt="our generated maze" /></p>

:ET